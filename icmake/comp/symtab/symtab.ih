#include "symtab.h"

#include <search.h>
#include <string.h>
#include <stdlib.h>

#include "../global.h"
#include "../util/util.h"

enum 
{
    capacityInc = 10
};


typedef struct
{
    char        *name;
    UNS16       address;
    size_t      nParams;
    ExprType    *paramType;     /* nParams elements */
    ExprType    returnType;
} FunInfo;

typedef struct
{
    FunInfo *info;
    size_t nFunctions;
    size_t capacity;
} FunInfoTab;
   
extern FunInfoTab gs_functions; /* symbol table for functions */
int st_findFun(void const *key, void const *funInfo);


typedef struct
{
    char        *name;
    UNS16       value;
    ExprType    type;
} VarInfo;

typedef struct
{
    VarInfo *info;
    size_t nVars;
    size_t capacity;
} VarTab;

typedef struct
{
    size_t *index;
    size_t nVars;
    size_t capacity;
} VarIndices;
   
typedef struct
{
    VarTab *varTab;             /* points to global [0] or local [1] vars */

    size_t nParams;             /* the number of parameters of the function 
                                    currently being defined */
    VarIndices *indices;        /* level 0 holds indices of global vars */
    size_t nLevels;             /* at least 1: the global level */
    size_t capacity;
} VarRef;


extern VarTab *gs_compareTable; /* set by st_findVar for st_compareVars 
                                        to gs_global or gs_local    */

extern VarRef gs_vars;     /* 
                                    OLD:
                                   VarRef objects per nesting level. At
                                    each nesting level a new VarRef is
                                    used allowing access  to the VarInfo
                                    records of variables that are defined at
                                    that level.
                                   At the end of a function gs_level is reset,
                                    and gs_local contains the info of all
                                    variables that are locally defined,
                                    allowing the frame to be constructed
                                */
//extern size_t gs_nestingLevel;
//extern size_t gs_varsCapacity;

size_t       st_nestingLevel();
VarIndices  *st_topLevel();
VarTab      *st_varTab();       /* vartab to use, given the nestinglevel */


SymtabIndex st_varIdx();        /* idx == -1: g_lexstring not found */
int         st_compareVars(char const *key, size_t *idxPtr); /* compare key 
                                                to entry in gs_compareTable */
int         st_findVar(size_t depth);   /* find g_lexstring in gs_vars */


SymtabIndex st_addVar(ExprType type);   /* add variable to the topmost symbol 
                                            table */
size_t st_nextVarIdx();         /* return idx of next variable */
size_t *st_stNewIdxPtr();       /* pointer to the next available index[] */
size_t st_newVarIdx(VarInfo **vi); /* idx of an uninitialized record of a new 
                                        variable */

void st_deleteVars(VarTab *varTab); /* delete all info allocated by VarInfo
                                        objects */

/*------------------------ */

//int st_defineGlobalVar(ExprType type);  /* return -1 if already def'd,
//                                         otherwise return new var's idx */
//
//void st_newGlobal(ExprType type);       /* define a new global var. */
//
//void st_iniVar(VarInfo *next, ExprType type);   /* initialize new variable */

//void st_symtab_init(Symtab *location);
//
//Symbol *st_next(Symtab *symtab_ptr); /* return addr. of next available elem. */
//
//int st_find(Symtab *symtab);        /* returns -1 if not found */
//void st_free(Symtab *table);        /* free the name fiels of the table */
//
//                                    /* assign param. types */
//void st_setParamTypes(Symbol *last, size_t nParams);
//
