#include "parser.h"

#include <string.h>
#include <stdlib.h>
#include <stdarg.h>

#include "../../rss/rss.h"
#include "../scanner/scanner.h"
#include "../util/util.h"
#include "../symtab/symtab.h"

#include "semval.ih"


#define test_type(e,v)          ((e)->type &   (v))
#define set_type(e,v)           ((e)->type =   (v))
#define up_type(e,v)            ((e)->type |=  (v))
#define down_type(e,v)          ((e)->type &= ~(v))

#define e_typeMask                (e_int | e_list | e_str | e_bool)
#define codestruc(estruc, x)    (&(((SemVal *)((estruc)->code))[x]))

typedef enum                        /* order of elements must follow */
{                                   /* definition of hidden[] in     */
    he_older = 0,                   /* data.c                        */
    he_younger = 1,                 /* reserved values 0 and 1 */

    he_                             /* must be last ! */
} Hidden;

typedef struct
{
    char *name;                      /* name of the hidden fun */
    char *source;                   /* source of the hidden function */
    size_t type;                    /* returntype */
    size_t this;                    /* set to 1 if called */
    size_t nargs;                   /* # of arguments */
} HiddenFunction;

typedef struct
{
    unsigned index;                         /* index in stringsection */
    char *string;                           /* string itself */
} StringTable;

typedef enum
{
    err_openpar_expected,
    err_closepar_expected,
    err_openbrace_expected,
    err_closebrace_expected,
    err_semicol_expected,
    err_assign_expected,
    err_in_expression,
    err_comma_expected,
    err_statements_expected,
    err_identifier_expected,
    err_code_or_vars_expected,
    err_comma_or_closepar_expected,
    err_number_expected,
    err_older_younger,
    err_backtick_expected
} PARSE_ERR_;


typedef enum
{
    pre_op,
    post_op
} PREPOST_;

typedef enum
{
    j_uncond,                               /* unconditional jump */
    j_truelist,                             /* jump batchpatch for truelist */
    j_falselist,                            /* jump backbatch for falselist */
    j_continuelist                          /* jump backp. for continuelist */
} JMP_COND_;

extern int      gp_parse_error;
extern size_t   gp_breakOK;
extern size_t   gp_nestLevel;
extern size_t   gp_stringsize;

extern char     gp_typeConflict[];
extern char    *gp_funstring[];
extern char     gp_illegalType[];
extern char    *gp_opstring[];
extern char     gp_lvalueNeeded[];
extern char     gp_illegalArgCount[];
extern char     gp_illegalCast[];

extern ExprType  gp_varType;

extern ExprType gp_opType[];

extern OPCODE_ gp_lastOp;

extern size_t   gp_dead_sp;
extern size_t  *gp_dead;
extern FILE    *gp_bin;

extern size_t   gp_hidden_called;
extern HiddenFunction gp_hiddenFun[];

extern size_t   gp_nStrings;
extern StringTable *gp_stringTable;

extern SemVal gp_init;                  /* code initializing globals */

extern char *gp_stringbuf;

extern int yydebug;

/* ================================================================== */

SemVal *addition (SemVal *, SemVal *);       /* + code */
SemVal *and_boolean (SemVal *, SemVal *);/* && code */
SemVal *assign  (SemVal *, SemVal *);        /*  = code (shell) */
SemVal *band (SemVal *, SemVal *);           /* & (binary) code */
SemVal *bnot (SemVal *);                      /* ~ code */
SemVal *bor  (SemVal *, SemVal *);           /* | (binary) code */
SemVal *break_stmnt (void);                /* process break stmnt */
SemVal *callfun(int funIdx, SemVal *);       /* call a function */
SemVal *cast (ExprType, SemVal *);         /* perform cast */
SemVal *catcode (SemVal *, SemVal *);    /* write info rval behind lval */
SemVal *cat_expr (SemVal *, SemVal *);   /* ,-separated expressions */
SemVal *cat_stmnt (SemVal *, SemVal *);  /* catenate/write stmnts */
SemVal *continue_stmnt (void);             /* process continue stmnt */
SemVal *divide (SemVal *, SemVal *);     /* / code */
SemVal *equal (SemVal *, SemVal *);      /* == code */
SemVal *exec_fprintf (ExprType, SemVal *); /* exec() and fprintf() */
SemVal *execute (SemVal *);               /* execute() (full arglist) */
SemVal *expr_stmnt (SemVal *);            /* expr ; code */
SemVal *fetchvar (void);                   /* fetch variable */
SemVal *firstarg (SemVal *);              /* (arg   code */
SemVal *first_stmnt (SemVal *);           /* catenate/write stmnts */
SemVal *for_stmnt (SemVal *, SemVal *,   /* for statement */
                       SemVal *, SemVal *);
SemVal *greater (SemVal *, SemVal *);   /* > code */
SemVal *gr_equal (SemVal *, SemVal *);  /* >= code */
SemVal *if_stmnt (SemVal *, SemVal *,    /* if code */
                               SemVal *);
SemVal *incdec (PREPOST_, OPCODE_,         /* E.g., c++ */
                               SemVal *);
SemVal *indexOp  (SemVal *, SemVal *);     /*  [] operator */
SemVal *makelist (SemVal *, ExprType);         /* makelist() */
SemVal *math_ass (SemVal *, SemVal *,    /* shell for math-asgnmt */
                       SemVal *(*)(SemVal *, SemVal *),
                       char *);
SemVal *modulo (SemVal *, SemVal *);    /* % code */
SemVal *multargs (SemVal *, SemVal *);  /* (arg1, arg2, ... code */
SemVal *multiply (SemVal *, SemVal *);  /* * code */
SemVal *negate (SemVal *);               /* - (unary) code */
SemVal *not_boolean (SemVal *);          /* ! code */
SemVal *old (SemVal *, SemVal *);       /* older code */
SemVal *onearg (ExprType, SemVal *);      /* fun(x)  code */
SemVal *optint_special (ExprType,           /* fun([int,] ...) */
                      SemVal *, SemVal *);
SemVal *optint_string (ExprType,        /* chdir(), system() */
                      SemVal *, SemVal *);
SemVal *or_boolean (SemVal *, SemVal *);/* || code */
SemVal *return_stmnt (ExprType, SemVal *);/* exit(), return(); */
SemVal *specials (ExprType, SemVal *);    /* fun(x, y, ...)  code */
SemVal *shl (SemVal *, SemVal *);            /* << (binary) code */
SemVal *shr (SemVal *, SemVal *);            /* >> (binary) code */
SemVal *smaller (SemVal *, SemVal *);   /* < code */
SemVal *sm_equal (SemVal *, SemVal *);  /* <= code */
SemVal *stackframe (ExprType);              /* initialize a stack-element */
SemVal *subtract (SemVal *, SemVal *);  /* - (binary) code */
SemVal *ternary(SemVal *cond, SemVal *iftrue, SemVal *iffalse);
SemVal *threeargs (ExprType, SemVal *,         /* fun(x, y, z)  code */
                        SemVal *, SemVal *);
SemVal *twoargs (ExprType, SemVal *,           /* fun(x, y)  code */
                               SemVal *);
SemVal *unequal (SemVal *, SemVal *);   /* != code */
SemVal *while_stmnt (SemVal *, SemVal *, int pureWhile);/* while code */
SemVal *young (SemVal *, SemVal *);     /* younger code */
SemVal *xor  (SemVal *, SemVal *);           /* ^ (binary) code */
SemVal *zeroargs (ExprType);               /* fun()  code */

void    close_fun (SemVal *);         /* close a function def. */
void    make_frame (void);             /* generate op_frame */
void    pop_dead(void);                 /* restore dead-level */
void    push_dead(void);                /* new dead-level */


SemVal *assignment(SemVal *lval, SemVal *rval, char *opstr);
SemVal *execute(SemVal *arr);
SemVal *icast(SemVal *e);
SemVal *insertarg(SemVal *insert, SemVal *mult);
SemVal *lcast(SemVal *e);
SemVal *nullframe(SemVal *e);
SemVal *scast(SemVal *e);
int     conflict(SemVal *lval, SemVal *rval, OPCODE_ opcode);
int     test_binop(OPCODE_ opcode, SemVal *lval, SemVal *rval);
int     test_operand(SemVal *e, OPCODE_ opcode);
int     yyerror(char *s);
size_t  lookstring(char *s);
size_t  rm_jmp_zero(register size_t codelen, unsigned *list, register size_t listlen);
void    addpatch(unsigned *list, size_t len, register size_t value);
void    btoi(SemVal *e);
void    callhidden(register int fun, SemVal *rarg);
void    callrss(SemVal *e, FUNNR_ funnr, ...);
void    catargs(SemVal *arr);
void    catstrings(SemVal *lval, SemVal *rval);
void    clearbin(SemVal *lval, SemVal *rval);
void    copy_to_pop(SemVal *e);
void    defcode(SemVal *lval, SemVal *rval, OPCODE_ opcode);
void    defineVar(void);        /* parameter or local var */
void    discard(SemVal *e);

//FBB void    enter();
//void    entervar();

void    etob(SemVal *e);
void    etoc(SemVal *e);
void    fetob(SemVal *e);
void    gencode(SemVal *e, OPCODE_ opcode, ...);
void    last_stmnt(SemVal *lval);
void    open_fun(void);
void    outcode(SemVal *ep, int value, register size_t size);
void    patchcontinue(SemVal *e);
void    patchfalse(SemVal *e);
void    patchtrue(SemVal *e);
void    patchVariables(void);

    /* 'pos' == 0 means: jump back to the begin of the code,
        otherwise jump forward to the end of the code
    */
void    patchup(int8_t *code, size_t len, unsigned *list, size_t listlen, int
                pos); 
void    patchup_continue(SemVal *e, int pos);
void    patchup_false(SemVal *e, int pos);
void    patchup_true(SemVal *e, int pos);

int     functionIdx(void);
void    checkArgumentTypes(size_t nParams, size_t funIdx, SemVal *a);
void    hidden_functions(void);
int     next_call(void);
